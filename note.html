<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>필기 웹앱</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
    }
    body {
      font-family: 'Noto Sans KR', sans-serif;
      background: #ecf0f1;
      display: flex;
      flex-direction: column;
    }
    .main-content {
      display: flex;
      height: 100vh;
      overflow: hidden;
    }
    .sidebar {
      width: 120px;
      background: #2c3e50;
      padding: 5px;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
      gap: 10px;
      overflow: hidden;
    }
    .setting-block {
      display: flex;
      flex-direction: column;
      align-items: center;
    }
    .setting-label {
      padding: 5px 10px;
      background-color: #2c3e50;
      color: #ffffff;
      font-size: 14px;
      border-radius: 5px;
      width: 100%;
      text-align: center;
      margin-bottom: 5px;
      white-space: nowrap;
    }
    .setting-input {
      padding: 5px;
      font-size: 14px;
      border-radius: 5px;
      border: none;
      text-align: center;
      width: 100%;
    }
    .tool-btn {
      width: 100%;
      padding: 2px;
      border: none;
      background-color: #ffffff;
      color: #2c3e50;
      font-size: 14px;
      border-radius: 5px;
      cursor: pointer;
      transition: background-color 0.3s ease;
      white-space: nowrap;
    }
    .tool-btn.active,
    .tool-btn:hover {
      background-color: #afceff;
      color: #000000;
    }
    .canvas-container {
      flex: 1;
      position: relative;
      overflow-y: auto;
      overflow-x: hidden;
      background-color: #fff;
      background-image: repeating-linear-gradient(0deg, transparent, transparent 24px, #f0f0f0 25px);
      margin: 0;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
      border: 1px solid #ddd;
    }
    canvas {
      display: block;
      width: 100%;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fabric.js/5.3.0/fabric.min.js"></script>
</head>
<body>
  <div class="main-content">
    <div class="sidebar">
      <div class="setting-block">
        <div class="setting-label">색상</div>
        <input type="color" id="penColor" value="#000000" class="setting-input">
      </div>
      <div class="setting-block">
        <div class="setting-label">크기</div>
        <select id="penSize" class="setting-input">
          <option value="1">작게</option>
          <option value="3">중간</option>
          <option value="5">크게</option>
          <option value="10">아주 크게</option>
        </select>
      </div>
      <hr style="width:100%; margin:10px 0;">
      <button class="tool-btn active" data-tool="pen">펜</button>
      <button class="tool-btn" data-tool="waterdrop">워터드롭</button>
      <button class="tool-btn" data-tool="areaSelect">영역 선택</button>
      <button class="tool-btn" data-tool="strokeEraser">획지우개</button>
      <button class="tool-btn" data-tool="eraser">지우개</button>
      <hr style="width:100%; margin:10px 0;">
      <button class="tool-btn" id="undo">실행 취소</button>
      <button class="tool-btn" id="clear">전체 지우기</button>
      <button class="tool-btn" id="save">필기 저장</button>
    </div>
    <div class="canvas-container">
      <canvas id="c"></canvas>
    </div>
  </div>
  
  <script>
  document.addEventListener("DOMContentLoaded", function () {
    const canvasContainer = document.querySelector(".canvas-container");
    const canvasElement = document.getElementById("c");
    const canvas = new fabric.Canvas("c", {
      isDrawingMode: true,
      backgroundColor: "transparent"
    });
      
    function resizeCanvas() {
      const containerWidth = canvasContainer.clientWidth;
      const extendedHeight = window.innerHeight * 3;
      canvas.setWidth(containerWidth);
      canvas.setHeight(extendedHeight);
      canvas.renderAll();
    }
    resizeCanvas();
    window.addEventListener("resize", resizeCanvas);
      
    canvasContainer.addEventListener("scroll", function() {
      canvas.calcOffset();
    });

    let isTouching = false;
    let startY = 0;
    let scrollTop = 0;

    canvasContainer.addEventListener("touchstart", function (e) {
      isTouching = true;
      startY = e.touches[0].clientY;
      scrollTop = canvasContainer.scrollTop;
    });

    canvasContainer.addEventListener("touchmove", function (e) {
      if (isTouching) {
        let moveY = e.touches[0].clientY;
        let diffY = startY - moveY;
        canvasContainer.scrollTop = scrollTop + diffY;
        e.preventDefault();
      }
    });

    canvasContainer.addEventListener("touchend", function () {
      isTouching = false;
    });

    let canvasHistory = [];
    function saveState() {
      canvasHistory.push(JSON.stringify(canvas));
    }
    canvas.on("path:created", function (opt) {
      const path = opt.path;
      if (currentTool === "strokeEraser") {
        eraseIntersectingPaths(path);
      } else {
        saveState();
      }
    });
    saveState();
      
    let currentTool = "pen";
    let originalPenSize = parseInt(document.getElementById("penSize").value, 10);
    let originalPenColor = document.getElementById("penColor").value;
    let tempEraserSize, tempEraserColor;
      
    function updateTool() {
      if (currentTool === "pen" || currentTool === "waterdrop") {
        canvas.isDrawingMode = true;
        canvas.selection = false;
        canvas.freeDrawingBrush = currentTool === "pen" ? new fabric.PencilBrush(canvas) : new fabric.CircleBrush(canvas);
        canvas.freeDrawingBrush.color = originalPenColor;
        canvas.freeDrawingBrush.width = originalPenSize;
        canvas.freeDrawingBrush.globalCompositeOperation = "source-over";
        canvas.freeDrawingBrush.opacity = 1;
      } else if (currentTool === "areaSelect") {
        canvas.isDrawingMode = false;
        canvas.selection = true;
      } else if (currentTool === "strokeEraser") {
        canvas.isDrawingMode = true;
        canvas.selection = false;
        canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
        canvas.freeDrawingBrush.color = "#ffffff";
        canvas.freeDrawingBrush.width = parseInt(document.getElementById("penSize").value, 10);
        canvas.freeDrawingBrush.globalCompositeOperation = "source-over";
        canvas.freeDrawingBrush.opacity = 1;
      } else if (currentTool === "eraser") {
        canvas.isDrawingMode = true;
        canvas.selection = false;
        canvas.freeDrawingBrush = new fabric.PencilBrush(canvas);
        tempEraserSize = 10;
        tempEraserColor = "#ffffff";
        canvas.freeDrawingBrush.width = tempEraserSize;
        canvas.freeDrawingBrush.color = tempEraserColor;
        canvas.freeDrawingBrush.globalCompositeOperation = "source-over";
        canvas.freeDrawingBrush.opacity = 1;
      }
    }
      
    function rectsIntersect(r1, r2) {
      return !(
        r2.left > r1.left + r1.width ||
        r2.left + r2.width < r1.left ||
        r2.top > r1.top + r1.height ||
        r2.top + r2.height < r1.top
      );
    }
      
    function eraseIntersectingPaths(eraserPath) {
      const eraserBox = eraserPath.getBoundingRect();
      let objectsToRemove = [];
      canvas.getObjects().forEach((obj) => {
        if (obj === eraserPath) return;
        const objBox = obj.getBoundingRect();
        if (rectsIntersect(eraserBox, objBox)) {
          objectsToRemove.push(obj);
        }
      });
      objectsToRemove.forEach((obj) => {
        canvas.remove(obj);
      });
      canvas.remove(eraserPath);
      canvas.renderAll();
      saveState();
    }
      
    const toolButtons = document.querySelectorAll(".sidebar .tool-btn[data-tool]");
    toolButtons.forEach((btn) => {
      btn.addEventListener("click", function () {
        toolButtons.forEach((b) => b.classList.remove("active"));
        btn.classList.add("active");
        
        if (currentTool === "pen" || currentTool === "waterdrop") {
          originalPenSize = parseInt(document.getElementById("penSize").value, 10);
          originalPenColor = document.getElementById("penColor").value;
        }
        
        currentTool = btn.getAttribute("data-tool");
        updateTool();
      });
    });
      
    document.getElementById("penColor").addEventListener("change", function () {
      if (currentTool === "pen" || currentTool === "waterdrop") {
        originalPenColor = this.value;
        updateTool();
      }
    });
      
    document.getElementById("penSize").addEventListener("change", function () {
      if (currentTool === "pen" || currentTool === "waterdrop" || currentTool === "strokeEraser") {
        originalPenSize = parseInt(this.value, 10);
        updateTool();
      }
    });
      
    document.getElementById("undo").addEventListener("click", function () {
      if (canvasHistory.length > 1) {
        canvasHistory.pop();
        const lastState = canvasHistory[canvasHistory.length - 1];
        canvas.loadFromJSON(lastState, function () {
          canvas.renderAll();
        });
      }
    });
      
    document.getElementById("clear").addEventListener("click", function () {
      canvas.clear();
      canvas.backgroundColor = "transparent";
      canvas.renderAll();
      saveState();
    });
      
    document.getElementById("save").addEventListener("click", function () {
      const dataURL = canvas.toDataURL({ format: "png" });
      const link = document.createElement("a");
      link.href = dataURL;
      link.download = "drawing.png";
      link.click();
    });
      
    canvas.upperCanvasEl.addEventListener("pointerdown", function (e) {
      if(e.pointerType === "touch"){
        e.preventDefault();
      }
      if(currentTool !== "areaSelect"){
        canvas.isDrawingMode = true;
      } else {
        canvas.isDrawingMode = false;
      }
    });
      
    const placeholderText = new fabric.Text("필기 노트", {
      left: canvas.width / 2,
      top: canvas.height / 10,
      fontSize: 100,
      fill: "#ccc",
      selectable: false,
      evented: false,
      originX: "center",
      originY: "center"
    });
    canvas.add(placeholderText);
      
    let hasDrawn = false;
    canvas.on("path:created", function () {
      if (!hasDrawn) {
        canvas.remove(placeholderText);
        hasDrawn = true;
      }
    });
  });
  </script>
</body>
</html>
